### A Pluto.jl notebook ###
# v0.20.5

using Markdown
using InteractiveUtils

# ╔═╡ f18a9488-13b8-11f0-342b-f99afaf3ac19
begin
	using Pkg
	Pkg.develop(path="/home/fritzsch/fri/JAC.jl")
end

# ╔═╡ fd4ef417-311f-43aa-a601-bf8a9d66b890
using JAC

# ╔═╡ 79374db5-1fbd-4499-b8d9-c7b840bdee52
html"""
<style>
	main {
		margin: 0 auto;
		max-width: 2000px;
    	padding-left: max(150px, 10%);
    	padding-right: max(150px, 10%);
	}
</style>
"""

# ╔═╡ 8d491602-2e68-4ce9-b949-859f91cfee9d
md"""
# Compute and compare different radial potentials
"""

# ╔═╡ 75061d53-4fb7-45a6-b8bb-c199d52479da
md"""
Let us first invoke JAC, either from the own source-code basis or simply by **using JAC**
"""

# ╔═╡ 956d7bd6-d59f-4daa-88b6-9b8879918d79
md"""
We shall here describe how different atomic (radial) potentials can be calculated and applied within the JAC toolbox.

Any (radial) potential is handled in JAC by the data struct `Radial.Potential` that (may) contain a name, the radial function ``Z(r)``
as well as the radial grid on which the potential is defined. The potential function `Zr` typically contains the effective charge ``Z(r)`` as seen by an electron, so that the full radial potential is given by ``V(r) = -\, Z(r)/r``. This convention has been frequently applied in atomic physics and has also been adopted in JAC, cf. `Radial.potential`. Perhaps, the simplest choice of a radial potential is the nuclear potential which, of course, depends on the nuclear model. Let us first simply consider a ``^{12}``C carbon atom with a Fermi-distributed nuclear charge and a standard radial grid.
"""

# ╔═╡ 4c2b4d2a-4b34-4f6a-9690-6efc9f2d3fea
begin
	grid     = Radial.Grid(true)
	nucModel = Nuclear.Model(6., "Fermi")
end

# ╔═╡ 759da271-0adf-4ae7-9642-8620c4c34690
md"""
Then, the corresponding nuclear potential is generated by simply calling:
"""

# ╔═╡ 182ee81f-d1f2-4b31-aa0b-0a26f11c50f0
nucPotential = Nuclear.nuclearPotential(nucModel, grid)

# ╔═╡ f230390a-479c-488d-9cbf-d9adf9af16c0
md"""
As seen from the output, the effective charge ``Z(r)`` vanishes near to the origin but quickly increases to the full charge at larger ``r``-values, i.e. near to the surface and outside of the nucleus.

To calculate atomic potentials, we also need to know the electron density around the nucleus. Most often, this density refers to a particular atomic level. Therefore, we first need to compute some of the low-lying levels of, for instance, neutral carbon. We shall here just compute the levels of the ground-state configuration ``1s^2 2s^2 2p^2``. We use the *simplest* approximation for these computation but will explain in some later tutorials how we could control and refine such simple structure calculations, if needed.
"""

# ╔═╡ 5a2ff26c-9c39-4423-9c4d-6c0e29f3762a
multiplet = SelfConsistent.performSCF([Configuration("1s^2 2s^2 2p^2")], nucModel, grid, AsfSettings())

# ╔═╡ a0e7c010-0e4e-4ef0-941a-ca99d35231d7
md"""
From this multiplet, we just take the lowest level (the ground level) in order to calculate the density for the (electronic) potential. In JAC, we have different choices for generating such an electronic potential that just arise from the electronic density, and as seen from `compute` at the REPL:

• ("radial potential: core-Hartree", grid::Radial.Grid, level::Level) ... to compute a (radial) core-Hartree potential for the given level; cf. Basics.computePotentialCoreHartree. A potential::RadialPotential is returned.

• ("radial potential: Kohn-Sham", grid::Radial.Grid, level::Level) ... to compute a (radial) Kohn-Sham potential for the given level; cf. Basics.computePotentialKohnSham. A potential::RadialPotential is returned.

• ("radial potential: Dirac-Fock-Slater", grid::Radial..Grid, level::Level) ... to compute a (radial) Dirac-Fock-Slater potential for the given level; this potential is rather simple but includes some undesired self-interaction and exhibits a wrong asymptotic behaviour. Cf. Basics.computePotentialDFS. A potential::RadialPotential is returned.
"""

# ╔═╡ 0af92442-4f44-40ec-8028-80fbe923eb00
begin
	level  = multiplet.levels[1]
	potCH  = compute("radial potential: core-Hartree", grid, level)
	potDFS = compute("radial potential: Dirac-Fock-Slater", grid, level)
	potKS = compute("radial potential: Kohn-Sham", grid, level)
end

# ╔═╡ 75bbe444-2ae1-4f66-ac92-4b6160d1c223


# ╔═╡ d70082f6-fa88-4b54-8306-46efe25138fc
md"""
# Still under construction !!!
"""

# ╔═╡ Cell order:
# ╟─79374db5-1fbd-4499-b8d9-c7b840bdee52
# ╟─8d491602-2e68-4ce9-b949-859f91cfee9d
# ╟─75061d53-4fb7-45a6-b8bb-c199d52479da
# ╟─f18a9488-13b8-11f0-342b-f99afaf3ac19
# ╠═fd4ef417-311f-43aa-a601-bf8a9d66b890
# ╟─956d7bd6-d59f-4daa-88b6-9b8879918d79
# ╠═4c2b4d2a-4b34-4f6a-9690-6efc9f2d3fea
# ╟─759da271-0adf-4ae7-9642-8620c4c34690
# ╠═182ee81f-d1f2-4b31-aa0b-0a26f11c50f0
# ╟─f230390a-479c-488d-9cbf-d9adf9af16c0
# ╠═5a2ff26c-9c39-4423-9c4d-6c0e29f3762a
# ╟─a0e7c010-0e4e-4ef0-941a-ca99d35231d7
# ╠═0af92442-4f44-40ec-8028-80fbe923eb00
# ╠═75bbe444-2ae1-4f66-ac92-4b6160d1c223
# ╟─d70082f6-fa88-4b54-8306-46efe25138fc
